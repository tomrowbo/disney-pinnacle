transaction {
  prepare(signer: AuthAccount) {
    // Deploy the DisneyPinnacleNFT contract
    signer.contracts.add(
      name: "DisneyPinnacleNFT",
      code: "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\naccess(all) contract DisneyPinnacleNFT: NonFungibleToken {\n    \n    access(all) var totalSupply: UInt64\n    \n    access(all) event ContractInitialized()\n    access(all) event Withdraw(id: UInt64, from: Address?)\n    access(all) event Deposit(id: UInt64, to: Address?)\n    access(all) event Minted(id: UInt64, recipient: Address, badgeType: UInt8, name: String)\n    \n    access(all) let CollectionStoragePath: StoragePath\n    access(all) let CollectionPublicPath: PublicPath\n    access(all) let MinterStoragePath: StoragePath\n    \n    // Badge Types\n    access(all) enum BadgeType: UInt8 {\n        access(all) case mickey\n        access(all) case minnie  \n        access(all) case donald\n        access(all) case goofy\n        access(all) case castle\n    }\n    \n    access(all) struct BadgeMetadata {\n        access(all) let badgeType: BadgeType\n        access(all) let name: String\n        access(all) let description: String\n        access(all) let image: String\n        access(all) let rarity: String\n        access(all) let attributes: {String: String}\n        \n        init(badgeType: BadgeType, name: String, description: String, image: String, rarity: String, attributes: {String: String}) {\n            self.badgeType = badgeType\n            self.name = name\n            self.description = description\n            self.image = image\n            self.rarity = rarity\n            self.attributes = attributes\n        }\n    }\n    \n    access(all) fun getBadgeMetadata(_ badgeType: BadgeType): BadgeMetadata {\n        switch badgeType {\n            case BadgeType.mickey:\n                return BadgeMetadata(\n                    badgeType: badgeType,\n                    name: \"Mickey Mouse Classic\",\n                    description: \"The iconic Mickey Mouse head silhouette\",\n                    image: \"https://easydrawingguides.com/wp-content/uploads/2022/07/easy-Mickey-Mouse-face-11.png\",\n                    rarity: \"Common\",\n                    attributes: {\"character\": \"Mickey Mouse\", \"series\": \"Classic Collection\", \"year\": \"2025\"}\n                )\n            case BadgeType.minnie:\n                return BadgeMetadata(\n                    badgeType: badgeType,\n                    name: \"Minnie Mouse Bow\",\n                    description: \"Minnie Mouse with her signature polka dot bow\",\n                    image: \"https://wallpapers.com/images/hd/minnie-mouse-red-polka-dot-bow-qauom9hxucgkbie6-qauom9hxucgkbie6.jpg\",\n                    rarity: \"Common\",\n                    attributes: {\"character\": \"Minnie Mouse\", \"series\": \"Classic Collection\", \"year\": \"2025\"}\n                )\n            case BadgeType.donald:\n                return BadgeMetadata(\n                    badgeType: badgeType,\n                    name: \"Donald Duck Sailor\",\n                    description: \"Donald Duck in his classic sailor outfit\",\n                    image: \"https://static.wikia.nocookie.net/characters/images/6/6f/Donald_Duck.png/revision/latest?cb=20240325202709\",\n                    rarity: \"Uncommon\",\n                    attributes: {\"character\": \"Donald Duck\", \"series\": \"Classic Collection\", \"year\": \"2025\"}\n                )\n            case BadgeType.goofy:\n                return BadgeMetadata(\n                    badgeType: badgeType,\n                    name: \"Goofy Hat\",\n                    description: \"Goofy with his signature green hat\",\n                    image: \"https://cdn.inspireuplift.com/uploads/images/seller_products/29661/1706084617_ul201223t2---goofy-head-face-smiling-svg-goofy-face-svg-disney-goofy-svg-ul201223t2png.png\",\n                    rarity: \"Uncommon\",\n                    attributes: {\"character\": \"Goofy\", \"series\": \"Classic Collection\", \"year\": \"2025\"}\n                )\n            case BadgeType.castle:\n                return BadgeMetadata(\n                    badgeType: badgeType,\n                    name: \"Castle Magic\",\n                    description: \"The iconic Cinderella Castle with magical sparkles\",\n                    image: \"https://cdn.creazilla.com/cliparts/15142/cinderella-castle-clipart-original.png\",\n                    rarity: \"Rare\",\n                    attributes: {\"location\": \"Magic Kingdom\", \"series\": \"Castle Collection\", \"year\": \"2025\"}\n                )\n            default:\n                panic(\"Invalid badge type\")\n        }\n    }\n    \n    access(all) resource NFT: NonFungibleToken.INFT, MetadataViews.Resolver {\n        access(all) let id: UInt64\n        access(all) let badgeType: BadgeType\n        access(all) let mintedAt: UFix64\n        \n        init(badgeType: BadgeType) {\n            self.id = self.uuid\n            self.badgeType = badgeType\n            self.mintedAt = getCurrentBlock().timestamp\n        }\n        \n        access(all) view fun getViews(): [Type] {\n            return [\n                Type<MetadataViews.Display>(),\n                Type<MetadataViews.Royalties>(),\n                Type<MetadataViews.Editions>(),\n                Type<MetadataViews.ExternalURL>(),\n                Type<MetadataViews.NFTCollectionData>(),\n                Type<MetadataViews.NFTCollectionDisplay>(),\n                Type<MetadataViews.Serial>(),\n                Type<MetadataViews.Traits>()\n            ]\n        }\n        \n        access(all) fun resolveView(_ view: Type): AnyStruct? {\n            let metadata = DisneyPinnacleNFT.getBadgeMetadata(self.badgeType)\n            \n            switch view {\n                case Type<MetadataViews.Display>():\n                    return MetadataViews.Display(\n                        name: metadata.name,\n                        description: metadata.description,\n                        thumbnail: MetadataViews.HTTPFile(url: metadata.image)\n                    )\n                case Type<MetadataViews.ExternalURL>():\n                    return MetadataViews.ExternalURL(\"https://disneypinnacle.com/nft/\".concat(self.id.toString()))\n                case Type<MetadataViews.NFTCollectionData>():\n                    return MetadataViews.NFTCollectionData(\n                        storagePath: DisneyPinnacleNFT.CollectionStoragePath,\n                        publicPath: DisneyPinnacleNFT.CollectionPublicPath,\n                        providerPath: /private/DisneyPinnacleNFTCollectionProvider,\n                        publicCollection: Type<&DisneyPinnacleNFT.Collection>(),\n                        publicLinkedType: Type<&DisneyPinnacleNFT.Collection>(),\n                        providerLinkedType: Type<&DisneyPinnacleNFT.Collection>(),\n                        createEmptyCollectionFunction: (fun (): @NonFungibleToken.Collection {\n                            return <-DisneyPinnacleNFT.createEmptyCollection()\n                        })\n                    )\n                case Type<MetadataViews.Traits>():\n                    let traits: [MetadataViews.Trait] = []\n                    for key in metadata.attributes.keys {\n                        traits.append(MetadataViews.Trait(name: key, value: metadata.attributes[key]!, displayType: nil, rarity: nil))\n                    }\n                    return MetadataViews.Traits(traits)\n            }\n            return nil\n        }\n    }\n    \n    access(all) resource interface DisneyPinnacleNFTCollectionPublic {\n        access(all) fun deposit(token: @NonFungibleToken.NFT)\n        access(all) fun getIDs(): [UInt64]\n        access(all) fun borrowNFT(id: UInt64): &NonFungibleToken.NFT\n        access(all) fun borrowDPNFT(id: UInt64): &DisneyPinnacleNFT.NFT? {\n            post {\n                (result == nil) || (result?.id == id):\n                    \"Cannot borrow DisneyPinnacleNFT reference: the ID of the returned reference is incorrect\"\n            }\n        }\n    }\n    \n    access(all) resource Collection: DisneyPinnacleNFTCollectionPublic, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection {\n        access(all) var ownedNFTs: @{UInt64: NonFungibleToken.NFT}\n        \n        init () {\n            self.ownedNFTs <- {}\n        }\n        \n        access(all) fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {\n            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(\"missing NFT\")\n            emit Withdraw(id: token.id, from: self.owner?.address)\n            return <-token\n        }\n        \n        access(all) fun deposit(token: @NonFungibleToken.NFT) {\n            let token <- token as! @DisneyPinnacleNFT.NFT\n            let id: UInt64 = token.id\n            emit Deposit(id: id, to: self.owner?.address)\n            self.ownedNFTs[id] <-! token\n        }\n        \n        access(all) fun getIDs(): [UInt64] {\n            return self.ownedNFTs.keys\n        }\n        \n        access(all) fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {\n            return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n        }\n        \n        access(all) fun borrowDPNFT(id: UInt64): &DisneyPinnacleNFT.NFT? {\n            if self.ownedNFTs[id] != nil {\n                return (&self.ownedNFTs[id] as &NonFungibleToken.NFT?) as! &DisneyPinnacleNFT.NFT?\n            }\n            return nil\n        }\n        \n        access(all) fun borrowViewResolver(id: UInt64): &{MetadataViews.Resolver} {\n            let nft = (&self.ownedNFTs[id] as &NonFungibleToken.NFT?)!\n            let dpNFT = nft as! &DisneyPinnacleNFT.NFT\n            return dpNFT\n        }\n    }\n    \n    access(all) fun createEmptyCollection(): @NonFungibleToken.Collection {\n        return <- create Collection()\n    }\n    \n    access(all) resource NFTMinter {\n        access(all) fun mintNFT(recipient: &{NonFungibleToken.Receiver}, badgeType: BadgeType) {\n            let metadata = DisneyPinnacleNFT.getBadgeMetadata(badgeType)\n            var newNFT <- create NFT(badgeType: badgeType)\n            let mintedID = newNFT.id\n            \n            recipient.deposit(token: <-newNFT)\n            \n            emit Minted(id: mintedID, recipient: recipient.owner!.address, badgeType: badgeType.rawValue, name: metadata.name)\n            \n            DisneyPinnacleNFT.totalSupply = DisneyPinnacleNFT.totalSupply + 1\n        }\n    }\n    \n    access(all) fun getRandomBadgeType(): BadgeType {\n        let blockHeight = getCurrentBlock().height\n        let timestamp = UInt64(getCurrentBlock().timestamp)\n        let randomSeed = blockHeight + timestamp\n        let badgeIndex = randomSeed % 5\n        \n        switch badgeIndex {\n            case 0: return BadgeType.mickey\n            case 1: return BadgeType.minnie\n            case 2: return BadgeType.donald\n            case 3: return BadgeType.goofy\n            case 4: return BadgeType.castle\n            default: return BadgeType.mickey\n        }\n    }\n    \n    init() {\n        self.totalSupply = 0\n        \n        self.CollectionStoragePath = /storage/DisneyPinnacleNFTCollection\n        self.CollectionPublicPath = /public/DisneyPinnacleNFTCollection\n        self.MinterStoragePath = /storage/DisneyPinnacleNFTMinter\n        \n        let collection <- create Collection()\n        self.account.save(<-collection, to: self.CollectionStoragePath)\n        \n        self.account.link<&DisneyPinnacleNFT.Collection>(\n            self.CollectionPublicPath,\n            target: self.CollectionStoragePath\n        )\n        \n        let minter <- create NFTMinter()\n        self.account.save(<-minter, to: self.MinterStoragePath)\n        \n        emit ContractInitialized()\n    }\n}".utf8
    )
  }
}